# secomp filtering

This page describe about the seccomp filtering. Seccomp provides syscall filtering. Seccomp exposes a system call to the userspace,
and a BPF generated code is passed to the kernel to filter out the packets.

The BPF code is generated by the userspace and passed to the kernel via the seccomp syscall. A userspace library interface is created to
reduce the complexity of generating and understanding the BPF code. `libseccoomp` exposes the following API.

seccomp provides filter mechnism to filter out system calls. This allows a powerful means to control what system calls to be called
by the given application, restricting access to various other resources offered by the kernel.

```c
scmp_filter_ctx seccomp_init(uint32_t default_action);
int seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,
                           int syscall, unsigned int arg-count, ...);
int seccomp_load(scmp_filter_ctx ctx);
```

The `seccomp_init` creates a default filter set. The `default_action` is one of the following.

```c
1. SCMP_ACT_ALLOW
2. SCMP_ACT_KILL
3. SCMP_ACT_ERRNO
4. SCMP_ACT_TRAP
5. SCMP_ACT_KILL_PROCESS
6. SCMP_ACT_TRACE
7. SCMP_ACT_LOG
8. SCMP_ACT_NOTIFY
```

most of the time the filters are created with `SCMP_ACT_ALLOW` flag. This will allow all the possible system calls.
`SCMP_ACT_KILL` will deny all the system calls and kills the process when any system call being called out.

For example the call to `seccomp_init` will look like this.

```c
scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);
if (!ctx) {
    return -1;
}
```

`seccomp_rule_add_exact` allows to add filters on top of the system calls. For example the following code will deny `write` system call to everything.

```c
scmp_ctx_t ctx;
int ret;

ctx = seccomp_init(SCMP_ACT_ALLOW);
if (!ctx) {
    return -1;
}

ret = seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 0);
if (ret < 0) {
    return -1;
}
```

The `seccomp_load` call performs the load of filter settings to the kernel. This call must be made so that filter setings will be applied in the kernel.

More sophisticated rules can be added. For example, the following code will dent writes to stdout and stderr.

```c
seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 1));
seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 2));
```

For example to test if writes on `stdout` are blocked, we can test with an `fprintf(stdout, ...)` statement.

An example code for such is described below:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <seccomp.h>

int main()
{
    scmp_filter_ctx ctx;
    int ret;

    ctx = seccomp_init(SCMP_ACT_ALLOW);
    if (!ctx) {
        return -1;
    }

    // deny writes to stdout - aka file descriptor 1 and kill program
    ret = seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 1));

    seccomp_load(ctx);

    fprintf(stderr, "stderr test data\n");
    fprintf(stdout, "stdout test data\n");
    fprintf(stderr, "stderr another test data wont be printed\n");

    return 0;
}
```

The program needs to be linked with `-lseccomp` linker flag.

Sample output is as follows,

```bash
./a.out 
stderr test data
Bad system call (core dumped)
```

It shows that the `fprintf(stdout, "stdout test data\n")` never printed, but also program terminated with `Bad system call (core dumped)` error.

Lets run the program with `strace`,

```bash
strace ./a.out 
execve("./a.out", ["./a.out"], 0x7ffc0c98a910 /* 45 vars */) = 0
brk(NULL)                               = 0x5635bfb22000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffe6e3b34b0) = -1 EINVAL (Invalid argument)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
newfstatat(3, "", {st_mode=S_IFREG|0644, st_size=68574, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 68574, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0a88ff0000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libseccomp.so.2", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@#\0\0\0\0\0\0"..., 832) = 832
newfstatat(3, "", {st_mode=S_IFREG|0644, st_size=137664, ...}, AT_EMPTY_PATH) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0a88fee000
mmap(NULL, 139616, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f0a88fcb000
mmap(0x7f0a88fcd000, 65536, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7f0a88fcd000
mmap(0x7f0a88fdd000, 61440, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12000) = 0x7f0a88fdd000
mmap(0x7f0a88fec000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x20000) = 0x7f0a88fec000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\240\206\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0 \0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0"..., 48, 848) = 48
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0+H)\227\201T\214\233\304R\352\306\3379\220%"..., 68, 896) = 68
newfstatat(3, "", {st_mode=S_IFREG|0755, st_size=1983576, ...}, AT_EMPTY_PATH) = 0
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
mmap(NULL, 2012056, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f0a88ddf000
mmap(0x7f0a88e05000, 1486848, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x26000) = 0x7f0a88e05000
mmap(0x7f0a88f70000, 311296, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x191000) = 0x7f0a88f70000
mmap(0x7f0a88fbc000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1dc000) = 0x7f0a88fbc000
mmap(0x7f0a88fc2000, 33688, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f0a88fc2000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0a88ddc000
arch_prctl(ARCH_SET_FS, 0x7f0a88ddc740) = 0
mprotect(0x7f0a88fbc000, 12288, PROT_READ) = 0
mprotect(0x7f0a88fec000, 4096, PROT_READ) = 0
mprotect(0x5635bf08d000, 4096, PROT_READ) = 0
mprotect(0x7f0a89033000, 8192, PROT_READ) = 0
munmap(0x7f0a88ff0000, 68574)           = 0
seccomp(SECCOMP_SET_MODE_STRICT, 1, NULL) = -1 EINVAL (Invalid argument)
seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC, NULL) = -1 EFAULT (Bad address)
seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_LOG, NULL) = -1 EFAULT (Bad address)
seccomp(SECCOMP_GET_ACTION_AVAIL, 0, [SECCOMP_RET_LOG]) = 0
seccomp(SECCOMP_GET_ACTION_AVAIL, 0, [SECCOMP_RET_KILL_PROCESS]) = 0
seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_SPEC_ALLOW, NULL) = -1 EFAULT (Bad address)
seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_NEW_LISTENER, NULL) = -1 EFAULT (Bad address)
seccomp(SECCOMP_GET_NOTIF_SIZES, 0, 0x7ffe6e3b34a2) = 0
seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC_ESRCH, NULL) = -1 EFAULT (Bad address)
brk(NULL)                               = 0x5635bfb22000
brk(0x5635bfb43000)                     = 0x5635bfb43000
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)  = 0
seccomp(SECCOMP_SET_MODE_FILTER, 0, {len=12, filter=0x5635bfb23420}) = 0
write(2, "stderr test data\n", 17stderr test data
)      = 17
newfstatat(1, "", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}, AT_EMPTY_PATH) = 0
write(1, "stdout test data\n", 17)      = ?
+++ killed by SIGSYS (core dumped) +++
Bad system call (core dumped)
```

Looking at the output, the `SIGSYS` triggered by the kernel as soon it finds the syscall `write` on file descriptor 1.

So reading back to the rule that is being used,

```c
seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 1));
```

The argument `SCMP_SYS(write)` returns a syscall number of `write` syscall.
The argument 1 refers to the number of arguments to be used in filter.
The argument `SCMP_A0` refers to the type of argument comparision filter we are setting.

`SCMP_A0` refers to argument 1, `SCMP_A1` refers to argument 2, `SCMP_A2` refers to argument 3 and so on etc.
The definition `SCMP_A0(SCMP_CMP_EQ, 1)` mean that `SCMP_CMP_EQ` is a comparision statement, 1 is the value of the argument 1.

This means that if the argument 1 of `write` system call should be denied with signal `SIGSYS` and with an action terminate.

the Termination `SCMP_ACT_KILL` can be changed to other types as well.

But mostly, `SCMP_ACT_ERRNO` is being used to simply return a syscall error, instead of terminating the program. Although, this will fail program, but it
also means that other sections followed by the failure condition will execute in the main program. So good testing should need to be done to take care of
the cases where the program being run in seccomp mode, should take and handle errors graciously.

An example of `ERRNO` instead of termination is shown below.

```c
seccomp_rule_add_exact(scmp_ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 1));
```

This will make the call to `write` system call fail. Below change to the code, will not print the `fprintf(stdout, ...)` statement on console. The modified program is shown below.

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <seccomp.h>

int main()
{
    scmp_filter_ctx ctx;
    int ret;

    ctx = seccomp_init(SCMP_ACT_ALLOW);
    if (!ctx) {
        return -1;
    }

    //ret = seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 1));
    ret = seccomp_rule_add_exact(ctx, SCMP_ACT_ERRNO(EINVAL), SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 1));
    //ret = seccomp_rule_add_exact(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, 2));

    seccomp_load(ctx);

    fprintf(stderr, "stderr test data\n");
    fprintf(stdout, "stdout test data\n");
    fprintf(stderr, "stderr another test data wont be printed\n");

    return 0;
}
```

The output is shown below,

```bash
./a.out 
stderr test data
stderr another test data wont be printed
```


So in general, using `SCMP_ACT_ALLOW` followed by the list of syscalls to perform __deny__ action on them.

But a more restrictive way to do is use of `SCMP_ACT_ERRNO(EPERM)` to deny every system call and then keep adding system calls one by one.
There is a way to validate all the system calls used by the given program. 

For example, `strace` can be used to list the system calls.

```bash
strace -c ./a.out 
stderr test data
stderr another test data wont be printed
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         2           read
  0.00    0.000000           0         3         1 write
  0.00    0.000000           0         3           close
  0.00    0.000000           0        12           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         3           brk
  0.00    0.000000           0         4           pread64
  0.00    0.000000           0         1         1 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           prctl
  0.00    0.000000           0         2         1 arch_prctl
  0.00    0.000000           0         3           openat
  0.00    0.000000           0         4           newfstatat
  0.00    0.000000           0        10         6 seccomp
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000           0        54         9 total
```

The above shows a listing of all the syscalls that can be used to set.

For example the following can be used with seccomp action `SCMP_ACT_ERRNO(EPERM)`.

```c
int syscall_num_set[] = {
    SCMP_SYS(read),
    SCMP_SYS(write),
    SCMP_SYS(close),
    SCMP_SYS(mmap),
    SCMP_SYS(mprotect),
    SCMP_SYS(munmap),
    SCMP_SYS(brk),
    SCMP_SYS(pread64),
    SCMP_SYS(access),
    SCMP_SYS(execve),
    SCMP_SYS(prctl),
    SCMP_SYS(arch_prctl),
    SCMP_SYS(openat),
    SCMP_SYS(newfstatat),
    SCMP_SYS(seccomp),
};

scmp_filter_ctx_t ctx;
int ret;

ctx = seccomp_init(SCMP_ACT_ERRNO(EPERM));
if (!ctx) {
    return -1;
}

for (uint32_t i = 0; i < sizeof(syscall_num_set) / sizeof(syscall_num_set[0]); i ++) {
    ret = seccomp_rule_add_exact(ctx, SCMP_ACT_ALLOW, syscall_num_set[i], 0);
}
```

This will effectively allow only the system calls offered in the seccomp filter.

A simple program can be written to execute a program after the filter has been set. The program can be executed with use of `execve` syscall.
the process executed with the `execve` system call will inherit the filter rules.
